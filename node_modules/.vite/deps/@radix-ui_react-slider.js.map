{
  "version": 3,
  "sources": ["../../@radix-ui/react-slider/node_modules/@radix-ui/number/dist/packages/core/number/src/index.ts", "../../@radix-ui/react-slider/node_modules/@radix-ui/number/dist/packages/core/number/src/number.ts", "../../@radix-ui/react-slider/node_modules/@radix-ui/primitive/dist/packages/core/primitive/src/index.ts", "../../@radix-ui/react-slider/node_modules/@radix-ui/primitive/dist/packages/core/primitive/src/primitive.tsx", "../../@radix-ui/react-primitive/node_modules/@radix-ui/react-slot/dist/packages/react/slot/src/index.ts", "../../@radix-ui/react-primitive/node_modules/@radix-ui/react-slot/dist/packages/react/slot/src/Slot.tsx", "../../@radix-ui/react-primitive/dist/packages/react/primitive/src/index.ts", "../../@radix-ui/react-primitive/dist/packages/react/primitive/src/Primitive.tsx", "../../@radix-ui/react-slider/node_modules/@radix-ui/react-slot/dist/packages/react/slot/src/index.ts", "../../@radix-ui/react-slider/node_modules/@radix-ui/react-slot/dist/packages/react/slot/src/Slot.tsx", "../../@radix-ui/react-slider/node_modules/@radix-ui/react-collection/dist/packages/react/collection/src/index.ts", "../../@radix-ui/react-slider/node_modules/@radix-ui/react-collection/dist/packages/react/collection/src/Collection.tsx", "../../@radix-ui/react-slider/dist/packages/react/slider/src/index.ts", "../../@radix-ui/react-slider/dist/packages/react/slider/src/Slider.tsx"],
  "sourcesContent": ["export { clamp } from './number';\n", "function clamp(value: number, [min, max]: [number, number]): number {\n  return Math.min(max, Math.max(min, value));\n}\n\nexport { clamp };\n", "export { composeEventHandlers } from './primitive';\n", "function composeEventHandlers<E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (checkForDefaultPrevented === false || !((event as unknown) as Event).defaultPrevented) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\nexport { composeEventHandlers };\n", "export {\n  Slot,\n  Slottable,\n  //\n  Root,\n} from './Slot';\nexport type { SlotProps } from './Slot';\n", "import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\nconst Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const childrenArray = React.Children.toArray(children);\n  const slottable = childrenArray.find(isSlottable);\n\n  if (slottable) {\n    // the new element to render is the one passed as a child of `Slottable`\n    const newElement = slottable.props.children as React.ReactNode;\n\n    const newChildren = childrenArray.map((child) => {\n      if (child === slottable) {\n        // because the new element will be the one rendered, we are only interested\n        // in grabbing its children (`newElement.props.children`)\n        if (React.Children.count(newElement) > 1) return React.Children.only(null);\n        return React.isValidElement(newElement)\n          ? (newElement.props.children as React.ReactNode)\n          : null;\n      } else {\n        return child;\n      }\n    });\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {React.isValidElement(newElement)\n          ? React.cloneElement(newElement, undefined, newChildren)\n          : null}\n      </SlotClone>\n    );\n  }\n\n  return (\n    <SlotClone {...slotProps} ref={forwardedRef}>\n      {children}\n    </SlotClone>\n  );\n});\n\nSlot.displayName = 'Slot';\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\nconst SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.isValidElement(children)) {\n    return React.cloneElement(children, {\n      ...mergeProps(slotProps, children.props),\n      ref: composeRefs(forwardedRef, (children as any).ref),\n    });\n  }\n\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\n\nSlotClone.displayName = 'SlotClone';\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst Slottable = ({ children }: { children: React.ReactNode }) => {\n  return <>{children}</>;\n};\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(child: React.ReactNode): child is React.ReactElement {\n  return React.isValidElement(child) && child.type === Slottable;\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    // if it's a handler, modify the override by composing the base handler\n    if (isHandler) {\n      overrideProps[propName] = (...args: unknown[]) => {\n        childPropValue?.(...args);\n        slotPropValue?.(...args);\n      };\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\nconst Root = Slot;\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Root,\n};\nexport type { SlotProps };\n", "export {\n  Primitive,\n  //\n  Root,\n  //\n  dispatchDiscreteCustomEvent,\n} from './Primitive';\nexport type { ComponentPropsWithoutRef, PrimitivePropsWithRef } from './Primitive';\n", "import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { Slot } from '@radix-ui/react-slot';\n\nconst NODES = [\n  'a',\n  'button',\n  'div',\n  'h2',\n  'h3',\n  'img',\n  'li',\n  'nav',\n  'ol',\n  'p',\n  'span',\n  'svg',\n  'ul',\n] as const;\n\n// Temporary while we await merge of this fix:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/pull/55396\n// prettier-ignore\ntype PropsWithoutRef<P> = P extends any ? ('ref' extends keyof P ? Pick<P, Exclude<keyof P, 'ref'>> : P) : P;\ntype ComponentPropsWithoutRef<T extends React.ElementType> = PropsWithoutRef<\n  React.ComponentProps<T>\n>;\n\ntype Primitives = { [E in typeof NODES[number]]: PrimitiveForwardRefComponent<E> };\ntype PrimitivePropsWithRef<E extends React.ElementType> = React.ComponentPropsWithRef<E> & {\n  asChild?: boolean;\n};\n\ninterface PrimitiveForwardRefComponent<E extends React.ElementType>\n  extends React.ForwardRefExoticComponent<PrimitivePropsWithRef<E>> {}\n\n/* -------------------------------------------------------------------------------------------------\n * Primitive\n * -----------------------------------------------------------------------------------------------*/\n\nconst Primitive = NODES.reduce((primitive, node) => {\n  const Node = React.forwardRef((props: PrimitivePropsWithRef<typeof node>, forwardedRef: any) => {\n    const { asChild, ...primitiveProps } = props;\n    const Comp: any = asChild ? Slot : node;\n\n    React.useEffect(() => {\n      (window as any)[Symbol.for('radix-ui')] = true;\n    }, []);\n\n    return <Comp {...primitiveProps} ref={forwardedRef} />;\n  });\n\n  Node.displayName = `Primitive.${node}`;\n\n  return { ...primitive, [node]: Node };\n}, {} as Primitives);\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Flush custom event dispatch\n * https://github.com/radix-ui/primitives/pull/1378\n *\n * React batches *all* event handlers since version 18, this introduces certain considerations when using custom event types.\n *\n * Internally, React prioritises events in the following order:\n *  - discrete\n *  - continuous\n *  - default\n *\n * https://github.com/facebook/react/blob/a8a4742f1c54493df00da648a3f9d26e3db9c8b5/packages/react-dom/src/events/ReactDOMEventListener.js#L294-L350\n *\n * `discrete` is an  important distinction as updates within these events are applied immediately.\n * React however, is not able to infer the priority of custom event types due to how they are detected internally.\n * Because of this, it's possible for updates from custom events to be unexpectedly batched when\n * dispatched by another `discrete` event.\n *\n * In order to ensure that updates from custom events are applied predictably, we need to manually flush the batch.\n * This utility should be used when dispatching a custom event from within another `discrete` event, this utility\n * is not nessesary when dispatching known event types, or if dispatching a custom type inside a non-discrete event.\n * For example:\n *\n * dispatching a known click ðŸ‘Ž\n * target.dispatchEvent(new Event(â€˜clickâ€™))\n *\n * dispatching a custom type within a non-discrete event ðŸ‘Ž\n * onScroll={(event) => event.target.dispatchEvent(new CustomEvent(â€˜customTypeâ€™))}\n *\n * dispatching a custom type within a `discrete` event ðŸ‘\n * onPointerDown={(event) => dispatchDiscreteCustomEvent(event.target, new CustomEvent(â€˜customTypeâ€™))}\n *\n * Note: though React classifies `focus`, `focusin` and `focusout` events as `discrete`, it's  not recommended to use\n * this utility with them. This is because it's possible for those handlers to be called implicitly during render\n * e.g. when focus is within a component as it is unmounted, or when managing focus on mount.\n */\n\nfunction dispatchDiscreteCustomEvent<E extends CustomEvent>(target: E['target'], event: E) {\n  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Primitive;\n\nexport {\n  Primitive,\n  //\n  Root,\n  //\n  dispatchDiscreteCustomEvent,\n};\nexport type { ComponentPropsWithoutRef, PrimitivePropsWithRef };\n", "export {\n  Slot,\n  Slottable,\n  //\n  Root,\n} from './Slot';\nexport type { SlotProps } from './Slot';\n", "import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\nconst Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const childrenArray = React.Children.toArray(children);\n  const slottable = childrenArray.find(isSlottable);\n\n  if (slottable) {\n    // the new element to render is the one passed as a child of `Slottable`\n    const newElement = slottable.props.children as React.ReactNode;\n\n    const newChildren = childrenArray.map((child) => {\n      if (child === slottable) {\n        // because the new element will be the one rendered, we are only interested\n        // in grabbing its children (`newElement.props.children`)\n        if (React.Children.count(newElement) > 1) return React.Children.only(null);\n        return React.isValidElement(newElement)\n          ? (newElement.props.children as React.ReactNode)\n          : null;\n      } else {\n        return child;\n      }\n    });\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {React.isValidElement(newElement)\n          ? React.cloneElement(newElement, undefined, newChildren)\n          : null}\n      </SlotClone>\n    );\n  }\n\n  return (\n    <SlotClone {...slotProps} ref={forwardedRef}>\n      {children}\n    </SlotClone>\n  );\n});\n\nSlot.displayName = 'Slot';\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\nconst SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.isValidElement(children)) {\n    return React.cloneElement(children, {\n      ...mergeProps(slotProps, children.props),\n      ref: composeRefs(forwardedRef, (children as any).ref),\n    });\n  }\n\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\n\nSlotClone.displayName = 'SlotClone';\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst Slottable = ({ children }: { children: React.ReactNode }) => {\n  return <>{children}</>;\n};\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(child: React.ReactNode): child is React.ReactElement {\n  return React.isValidElement(child) && child.type === Slottable;\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    // if it's a handler, modify the override by composing the base handler\n    if (isHandler) {\n      overrideProps[propName] = (...args: unknown[]) => {\n        childPropValue?.(...args);\n        slotPropValue?.(...args);\n      };\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\nconst Root = Slot;\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Root,\n};\nexport type { SlotProps };\n", "export { createCollection } from './Collection';\nexport type { CollectionProps } from './Collection';\n", "import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Slot } from '@radix-ui/react-slot';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\ntype SlotProps = Radix.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>â€¦</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement>;\n    itemMap: Map<React.RefObject<ItemElement>, { ref: React.RefObject<ItemElement> } & ItemData>;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <Slot ref={composedRefs}>{children}</Slot>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <Slot {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </Slot>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n", "export {\n  createSliderScope,\n  //\n  Slider,\n  SliderTrack,\n  SliderRange,\n  SliderThumb,\n  //\n  Root,\n  Track,\n  Range,\n  Thumb,\n} from './Slider';\nexport type { SliderProps, SliderTrackProps, SliderRangeProps, SliderThumbProps } from './Slider';\n", "import * as React from 'react';\nimport { clamp } from '@radix-ui/number';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { createCollection } from '@radix-ui/react-collection';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst PAGE_KEYS = ['PageUp', 'PageDown'];\nconst ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\nconst BACK_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowDown', 'Home', 'ArrowLeft', 'PageDown'],\n  rtl: ['ArrowDown', 'Home', 'ArrowRight', 'PageDown'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Slider\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLIDER_NAME = 'Slider';\n\nconst [Collection, useCollection, createCollectionScope] =\n  createCollection<SliderThumbElement>(SLIDER_NAME);\n\ntype ScopedProps<P> = P & { __scopeSlider?: Scope };\nconst [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [\n  createCollectionScope,\n]);\n\ntype SliderContextValue = {\n  disabled?: boolean;\n  min: number;\n  max: number;\n  values: number[];\n  valueIndexToChangeRef: React.MutableRefObject<number>;\n  thumbs: Set<SliderThumbElement>;\n  orientation: SliderProps['orientation'];\n};\n\nconst [SliderProvider, useSliderContext] = createSliderContext<SliderContextValue>(SLIDER_NAME);\n\ntype SliderElement = SliderHorizontalElement | SliderVerticalElement;\ninterface SliderProps\n  extends Omit<\n    SliderHorizontalProps | SliderVerticalProps,\n    keyof SliderOrientationPrivateProps | 'defaultValue'\n  > {\n  name?: string;\n  disabled?: boolean;\n  orientation?: React.AriaAttributes['aria-orientation'];\n  dir?: Direction;\n  min?: number;\n  max?: number;\n  step?: number;\n  minStepsBetweenThumbs?: number;\n  value?: number[];\n  defaultValue?: number[];\n  onValueChange?(value: number[]): void;\n}\n\nconst Slider = React.forwardRef<SliderElement, SliderProps>(\n  (props: ScopedProps<SliderProps>, forwardedRef) => {\n    const {\n      name,\n      min = 0,\n      max = 100,\n      step = 1,\n      orientation = 'horizontal',\n      disabled = false,\n      minStepsBetweenThumbs = 0,\n      defaultValue = [min],\n      value,\n      onValueChange = () => {},\n      ...sliderProps\n    } = props;\n    const [slider, setSlider] = React.useState<HTMLSpanElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));\n    const thumbRefs = React.useRef<SliderContextValue['thumbs']>(new Set());\n    const valueIndexToChangeRef = React.useRef<number>(0);\n    const isHorizontal = orientation === 'horizontal';\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = slider ? Boolean(slider.closest('form')) : true;\n    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;\n\n    const [values = [], setValues] = useControllableState({\n      prop: value,\n      defaultProp: defaultValue,\n      onChange: (value) => {\n        const thumbs = [...thumbRefs.current];\n        thumbs[valueIndexToChangeRef.current]?.focus();\n        onValueChange(value);\n      },\n    });\n\n    function handleSlideStart(value: number) {\n      const closestIndex = getClosestValueIndex(values, value);\n      updateValues(value, closestIndex);\n    }\n\n    function handleSlideMove(value: number) {\n      updateValues(value, valueIndexToChangeRef.current);\n    }\n\n    function updateValues(value: number, atIndex: number) {\n      const decimalCount = getDecimalCount(step);\n      const snapToStep = roundValue(Math.round((value - min) / step) * step + min, decimalCount);\n      const nextValue = clamp(snapToStep, [min, max]);\n\n      setValues((prevValues = []) => {\n        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);\n        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {\n          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);\n          return String(nextValues) === String(prevValues) ? prevValues : nextValues;\n        } else {\n          return prevValues;\n        }\n      });\n    }\n\n    return (\n      <SliderProvider\n        scope={props.__scopeSlider}\n        disabled={disabled}\n        min={min}\n        max={max}\n        valueIndexToChangeRef={valueIndexToChangeRef}\n        thumbs={thumbRefs.current}\n        values={values}\n        orientation={orientation}\n      >\n        <Collection.Provider scope={props.__scopeSlider}>\n          <Collection.Slot scope={props.__scopeSlider}>\n            <SliderOrientation\n              aria-disabled={disabled}\n              data-disabled={disabled ? '' : undefined}\n              {...sliderProps}\n              ref={composedRefs}\n              min={min}\n              max={max}\n              onSlideStart={disabled ? undefined : handleSlideStart}\n              onSlideMove={disabled ? undefined : handleSlideMove}\n              onHomeKeyDown={() => !disabled && updateValues(min, 0)}\n              onEndKeyDown={() => !disabled && updateValues(max, values.length - 1)}\n              onStepKeyDown={({ event, direction: stepDirection }) => {\n                if (!disabled) {\n                  const isPageKey = PAGE_KEYS.includes(event.key);\n                  const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.includes(event.key));\n                  const multiplier = isSkipKey ? 10 : 1;\n                  const atIndex = valueIndexToChangeRef.current;\n                  const value = values[atIndex];\n                  const stepInDirection = step * multiplier * stepDirection;\n                  updateValues(value + stepInDirection, atIndex);\n                }\n              }}\n            />\n          </Collection.Slot>\n        </Collection.Provider>\n        {isFormControl &&\n          values.map((value, index) => (\n            <BubbleInput\n              key={index}\n              name={name ? name + (values.length > 1 ? '[]' : '') : undefined}\n              value={value}\n            />\n          ))}\n      </SliderProvider>\n    );\n  }\n);\n\nSlider.displayName = SLIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderHorizontal\n * -----------------------------------------------------------------------------------------------*/\n\nconst [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext<{\n  startEdge: 'bottom' | 'left' | 'right';\n  endEdge: 'top' | 'right' | 'left';\n  size: keyof NonNullable<ReturnType<typeof useSize>>;\n  direction: number;\n}>(SLIDER_NAME, {\n  startEdge: 'left',\n  endEdge: 'right',\n  size: 'width',\n  direction: 1,\n});\n\ntype SliderOrientationPrivateProps = {\n  min: number;\n  max: number;\n  onSlideStart?(value: number): void;\n  onSlideMove?(value: number): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(step: { event: React.KeyboardEvent; direction: number }): void;\n};\ninterface SliderOrientationProps\n  extends Omit<SliderImplProps, keyof SliderImplPrivateProps>,\n    SliderOrientationPrivateProps {}\n\ntype SliderHorizontalElement = SliderImplElement;\ninterface SliderHorizontalProps extends SliderOrientationProps {\n  dir?: Direction;\n}\n\nconst SliderHorizontal = React.forwardRef<SliderHorizontalElement, SliderHorizontalProps>(\n  (props: ScopedProps<SliderHorizontalProps>, forwardedRef) => {\n    const { min, max, dir, onSlideStart, onSlideMove, onStepKeyDown, ...sliderProps } = props;\n    const [slider, setSlider] = React.useState<SliderImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));\n    const rectRef = React.useRef<ClientRect>();\n    const direction = useDirection(dir);\n    const isDirectionLTR = direction === 'ltr';\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || slider!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.width];\n      const output: [number, number] = isDirectionLTR ? [min, max] : [max, min];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.left);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge={isDirectionLTR ? 'left' : 'right'}\n        endEdge={isDirectionLTR ? 'right' : 'left'}\n        direction={isDirectionLTR ? 1 : -1}\n        size=\"width\"\n      >\n        <SliderImpl\n          dir={direction}\n          data-orientation=\"horizontal\"\n          {...sliderProps}\n          ref={composedRefs}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateX(-50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => (rectRef.current = undefined)}\n          onStepKeyDown={(event) => {\n            const isBackKey = BACK_KEYS[direction].includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderVertical\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderVerticalElement = SliderImplElement;\ninterface SliderVerticalProps extends SliderOrientationProps {}\n\nconst SliderVertical = React.forwardRef<SliderVerticalElement, SliderVerticalProps>(\n  (props: ScopedProps<SliderVerticalProps>, forwardedRef) => {\n    const { min, max, onSlideStart, onSlideMove, onStepKeyDown, ...sliderProps } = props;\n    const sliderRef = React.useRef<SliderImplElement>(null);\n    const ref = useComposedRefs(forwardedRef, sliderRef);\n    const rectRef = React.useRef<ClientRect>();\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || sliderRef.current!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.height];\n      const output: [number, number] = [max, min];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.top);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge=\"bottom\"\n        endEdge=\"top\"\n        size=\"height\"\n        direction={1}\n      >\n        <SliderImpl\n          data-orientation=\"vertical\"\n          {...sliderProps}\n          ref={ref}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateY(50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => (rectRef.current = undefined)}\n          onStepKeyDown={(event) => {\n            const isBackKey = BACK_KEYS.ltr.includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderImpl\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderImplElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ntype SliderImplPrivateProps = {\n  onSlideStart(event: React.PointerEvent): void;\n  onSlideMove(event: React.PointerEvent): void;\n  onSlideEnd(event: React.PointerEvent): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(event: React.KeyboardEvent): void;\n};\ninterface SliderImplProps extends PrimitiveDivProps, SliderImplPrivateProps {}\n\nconst SliderImpl = React.forwardRef<SliderImplElement, SliderImplProps>(\n  (props: ScopedProps<SliderImplProps>, forwardedRef) => {\n    const {\n      __scopeSlider,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onHomeKeyDown,\n      onEndKeyDown,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const context = useSliderContext(SLIDER_NAME, __scopeSlider);\n\n    return (\n      <Primitive.span\n        {...sliderProps}\n        ref={forwardedRef}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          if (event.key === 'Home') {\n            onHomeKeyDown(event);\n            // Prevent scrolling to page start\n            event.preventDefault();\n          } else if (event.key === 'End') {\n            onEndKeyDown(event);\n            // Prevent scrolling to page end\n            event.preventDefault();\n          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\n            onStepKeyDown(event);\n            // Prevent scrolling for directional key presses\n            event.preventDefault();\n          }\n        })}\n        onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n          const target = event.target as HTMLElement;\n          target.setPointerCapture(event.pointerId);\n          // Prevent browser focus behaviour because we focus a thumb manually when values change.\n          event.preventDefault();\n          // Touch devices have a delay before focusing so won't focus if touch immediately moves\n          // away from target (sliding). We want thumb to focus regardless.\n          if (context.thumbs.has(target)) {\n            target.focus();\n          } else {\n            onSlideStart(event);\n          }\n        })}\n        onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);\n        })}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) {\n            target.releasePointerCapture(event.pointerId);\n            onSlideEnd(event);\n          }\n        })}\n      />\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderTrack\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRACK_NAME = 'SliderTrack';\n\ntype SliderTrackElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SliderTrackProps extends PrimitiveSpanProps {}\n\nconst SliderTrack = React.forwardRef<SliderTrackElement, SliderTrackProps>(\n  (props: ScopedProps<SliderTrackProps>, forwardedRef) => {\n    const { __scopeSlider, ...trackProps } = props;\n    const context = useSliderContext(TRACK_NAME, __scopeSlider);\n    return (\n      <Primitive.span\n        data-disabled={context.disabled ? '' : undefined}\n        data-orientation={context.orientation}\n        {...trackProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nSliderTrack.displayName = TRACK_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderRange\n * -----------------------------------------------------------------------------------------------*/\n\nconst RANGE_NAME = 'SliderRange';\n\ntype SliderRangeElement = React.ElementRef<typeof Primitive.span>;\ninterface SliderRangeProps extends PrimitiveSpanProps {}\n\nconst SliderRange = React.forwardRef<SliderRangeElement, SliderRangeProps>(\n  (props: ScopedProps<SliderRangeProps>, forwardedRef) => {\n    const { __scopeSlider, ...rangeProps } = props;\n    const context = useSliderContext(RANGE_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);\n    const ref = React.useRef<HTMLSpanElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const valuesCount = context.values.length;\n    const percentages = context.values.map((value) =>\n      convertValueToPercentage(value, context.min, context.max)\n    );\n    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;\n    const offsetEnd = 100 - Math.max(...percentages);\n\n    return (\n      <Primitive.span\n        data-orientation={context.orientation}\n        data-disabled={context.disabled ? '' : undefined}\n        {...rangeProps}\n        ref={composedRefs}\n        style={{\n          ...props.style,\n          [orientation.startEdge]: offsetStart + '%',\n          [orientation.endEdge]: offsetEnd + '%',\n        }}\n      />\n    );\n  }\n);\n\nSliderRange.displayName = RANGE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderThumb\n * -----------------------------------------------------------------------------------------------*/\n\nconst THUMB_NAME = 'SliderThumb';\n\ntype SliderThumbElement = SliderThumbImplElement;\ninterface SliderThumbProps extends Omit<SliderThumbImplProps, 'index'> {}\n\nconst SliderThumb = React.forwardRef<SliderThumbElement, SliderThumbProps>(\n  (props: ScopedProps<SliderThumbProps>, forwardedRef) => {\n    const getItems = useCollection(props.__scopeSlider);\n    const [thumb, setThumb] = React.useState<SliderThumbImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    const index = React.useMemo(\n      () => (thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1),\n      [getItems, thumb]\n    );\n    return <SliderThumbImpl {...props} ref={composedRefs} index={index} />;\n  }\n);\n\ntype SliderThumbImplElement = React.ElementRef<typeof Primitive.span>;\ninterface SliderThumbImplProps extends PrimitiveSpanProps {\n  index: number;\n}\n\nconst SliderThumbImpl = React.forwardRef<SliderThumbImplElement, SliderThumbImplProps>(\n  (props: ScopedProps<SliderThumbImplProps>, forwardedRef) => {\n    const { __scopeSlider, index, ...thumbProps } = props;\n    const context = useSliderContext(THUMB_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);\n    const [thumb, setThumb] = React.useState<HTMLSpanElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    const size = useSize(thumb);\n    // We cast because index could be `-1` which would return undefined\n    const value = context.values[index] as number | undefined;\n    const percent =\n      value === undefined ? 0 : convertValueToPercentage(value, context.min, context.max);\n    const label = getLabel(index, context.values.length);\n    const orientationSize = size?.[orientation.size];\n    const thumbInBoundsOffset = orientationSize\n      ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction)\n      : 0;\n\n    React.useEffect(() => {\n      if (thumb) {\n        context.thumbs.add(thumb);\n        return () => {\n          context.thumbs.delete(thumb);\n        };\n      }\n    }, [thumb, context.thumbs]);\n\n    return (\n      <span\n        style={{\n          transform: 'var(--radix-slider-thumb-transform)',\n          position: 'absolute',\n          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`,\n        }}\n      >\n        <Collection.ItemSlot scope={props.__scopeSlider}>\n          <Primitive.span\n            role=\"slider\"\n            aria-label={props['aria-label'] || label}\n            aria-valuemin={context.min}\n            aria-valuenow={value}\n            aria-valuemax={context.max}\n            aria-orientation={context.orientation}\n            data-orientation={context.orientation}\n            data-disabled={context.disabled ? '' : undefined}\n            tabIndex={context.disabled ? undefined : 0}\n            {...thumbProps}\n            ref={composedRefs}\n            /**\n             * There will be no value on initial render while we work out the index so we hide thumbs\n             * without a value, otherwise SSR will render them in the wrong position before they\n             * snap into the correct position during hydration which would be visually jarring for\n             * slower connections.\n             */\n            style={value === undefined ? { display: 'none' } : props.style}\n            onFocus={composeEventHandlers(props.onFocus, () => {\n              context.valueIndexToChangeRef.current = index;\n            })}\n          />\n        </Collection.ItemSlot>\n      </span>\n    );\n  }\n);\n\nSliderThumb.displayName = THUMB_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst BubbleInput = (props: Radix.ComponentPropsWithoutRef<'input'>) => {\n  const { value, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevValue = usePrevious(value);\n\n  // Bubble value change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'value') as PropertyDescriptor;\n    const setValue = descriptor.set;\n    if (prevValue !== value && setValue) {\n      const event = new Event('input', { bubbles: true });\n      setValue.call(input, value);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value]);\n\n  /**\n   * We purposefully do not use `type=\"hidden\"` here otherwise forms that\n   * wrap it will not be able to access its value via the FormData API.\n   *\n   * We purposefully do not add the `value` attribute here to allow the value\n   * to be set programatically and bubble to any parent form `onChange` event.\n   * Adding the `value` will cause React to consider the programatic\n   * dispatch a duplicate and it will get swallowed.\n   */\n  return <input style={{ display: 'none' }} {...inputProps} ref={ref} defaultValue={value} />;\n};\n\nfunction getNextSortedValues(prevValues: number[] = [], nextValue: number, atIndex: number) {\n  const nextValues = [...prevValues];\n  nextValues[atIndex] = nextValue;\n  return nextValues.sort((a, b) => a - b);\n}\n\nfunction convertValueToPercentage(value: number, min: number, max: number) {\n  const maxSteps = max - min;\n  const percentPerStep = 100 / maxSteps;\n  return percentPerStep * (value - min);\n}\n\n/**\n * Returns a label for each thumb when there are two or more thumbs\n */\nfunction getLabel(index: number, totalValues: number) {\n  if (totalValues > 2) {\n    return `Value ${index + 1} of ${totalValues}`;\n  } else if (totalValues === 2) {\n    return ['Minimum', 'Maximum'][index];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Given a `values` array and a `nextValue`, determine which value in\n * the array is closest to `nextValue` and return its index.\n *\n * @example\n * // returns 1\n * getClosestValueIndex([10, 30], 25);\n */\nfunction getClosestValueIndex(values: number[], nextValue: number) {\n  if (values.length === 1) return 0;\n  const distances = values.map((value) => Math.abs(value - nextValue));\n  const closestDistance = Math.min(...distances);\n  return distances.indexOf(closestDistance);\n}\n\n/**\n * Offsets the thumb centre point while sliding to ensure it remains\n * within the bounds of the slider when reaching the edges\n */\nfunction getThumbInBoundsOffset(width: number, left: number, direction: number) {\n  const halfWidth = width / 2;\n  const halfPercent = 50;\n  const offset = linearScale([0, halfPercent], [0, halfWidth]);\n  return (halfWidth - offset(left) * direction) * direction;\n}\n\n/**\n * Gets an array of steps between each value.\n *\n * @example\n * // returns [1, 9]\n * getStepsBetweenValues([10, 11, 20]);\n */\nfunction getStepsBetweenValues(values: number[]) {\n  return values.slice(0, -1).map((value, index) => values[index + 1] - value);\n}\n\n/**\n * Verifies the minimum steps between all values is greater than or equal\n * to the expected minimum steps.\n *\n * @example\n * // returns false\n * hasMinStepsBetweenValues([1,2,3], 2);\n *\n * @example\n * // returns true\n * hasMinStepsBetweenValues([1,2,3], 1);\n */\nfunction hasMinStepsBetweenValues(values: number[], minStepsBetweenValues: number) {\n  if (minStepsBetweenValues > 0) {\n    const stepsBetweenValues = getStepsBetweenValues(values);\n    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);\n    return actualMinStepsBetweenValues >= minStepsBetweenValues;\n  }\n  return true;\n}\n\n// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nfunction linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n\nfunction getDecimalCount(value: number) {\n  return (String(value).split('.')[1] || '').length;\n}\n\nfunction roundValue(value: number, decimalCount: number) {\n  const rounder = Math.pow(10, decimalCount);\n  return Math.round(value * rounder) / rounder;\n}\n\nconst Root = Slider;\nconst Track = SliderTrack;\nconst Range = SliderRange;\nconst Thumb = SliderThumb;\n\nexport {\n  createSliderScope,\n  //\n  Slider,\n  SliderTrack,\n  SliderRange,\n  SliderThumb,\n  //\n  Root,\n  Track,\n  Range,\n  Thumb,\n};\nexport type { SliderProps, SliderTrackProps, SliderRangeProps, SliderThumbProps };\n"],
  "mappings": "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",
  "names": ["clamp", "value", "min", "max", "Math", "composeEventHandlers", "originalEventHandler", "ourEventHandler", "checkForDefaultPrevented", "handleEvent", "event", "defaultPrevented", "Slot", "React", "props", "forwardedRef", "slotProps", "childrenArray", "toArray", "children", "slottable", "find", "isSlottable", "newElement", "newChildren", "map", "child", "count", "only", "$9IrjX$createElement", "undefined", "displayName", "SlotClone", "mergeProps", "ref", "composeRefs", "Slottable", "$9IrjX$Fragment", "type", "childProps", "overrideProps", "propName", "slotPropValue", "childPropValue", "isHandler", "test", "args", "filter", "Boolean", "join", "NODES", "Primitive", "reduce", "primitive", "node", "Node", "React", "props", "forwardedRef", "primitiveProps", "Comp", "asChild", "Slot", "window", "Symbol", "for", "$4q5Fq$createElement", "displayName", "Slot", "React", "props", "forwardedRef", "slotProps", "childrenArray", "toArray", "children", "slottable", "find", "isSlottable", "newElement", "newChildren", "map", "child", "count", "only", "$9IrjX$createElement", "$5e63c961fc1ce211$var$SlotClone", "undefined", "displayName", "SlotClone", "mergeProps", "ref", "composeRefs", "Slottable", "$9IrjX$Fragment", "type", "childProps", "overrideProps", "propName", "slotPropValue", "childPropValue", "isHandler", "test", "args", "filter", "Boolean", "join", "createCollection", "name", "PROVIDER_NAME", "createCollectionContext", "createCollectionScope", "createContextScope", "CollectionProviderImpl", "useCollectionContext", "collectionRef", "current", "itemMap", "Map", "CollectionProvider", "props", "children", "ref", "React", "useRef", "$6vYhU$react", "COLLECTION_SLOT_NAME", "CollectionSlot", "forwardRef", "forwardedRef", "context", "scope", "composedRefs", "useComposedRefs", "$5e63c961fc1ce211$export$8c6ed5c666ac1360", "ITEM_SLOT_NAME", "ITEM_DATA_ATTR", "CollectionItemSlot", "itemData", "useEffect", "set", "delete", "useCollection", "getItems", "useCallback", "collectionNode", "orderedNodes", "Array", "from", "querySelectorAll", "items", "values", "orderedItems", "sort", "a", "b", "indexOf", "Provider", "Slot", "ItemSlot", "PAGE_KEYS", "ARROW_KEYS", "BACK_KEYS", "ltr", "rtl", "SLIDER_NAME", "Collection", "useCollection", "createCollectionScope", "createCollection", "createSliderContext", "createSliderScope", "createContextScope", "SliderProvider", "useSliderContext", "Slider", "React", "props", "forwardedRef", "min", "value", "sliderProps", "slider", "setSlider", "composedRefs", "useComposedRefs", "node", "thumbRefs", "Set", "valueIndexToChangeRef", "isHorizontal", "orientation", "isFormControl", "Boolean", "closest", "SliderOrientation", "SliderHorizontal", "SliderVertical", "values", "setValues", "useControllableState", "prop", "defaultProp", "defaultValue", "onChange", "thumbs", "current", "focus", "onValueChange", "handleSlideStart", "closestIndex", "getClosestValueIndex", "updateValues", "handleSlideMove", "atIndex", "decimalCount", "getDecimalCount", "step", "snapToStep", "roundValue", "Math", "round", "nextValue", "clamp", "max", "prevValues", "nextValues", "getNextSortedValues", "hasMinStepsBetweenValues", "minStepsBetweenThumbs", "indexOf", "String", "$g1Vy2$createElement", "__scopeSlider", "disabled", "undefined", "length", "direction", "stepDirection", "isPageKey", "includes", "event", "key", "isSkipKey", "shiftKey", "multiplier", "stepInDirection", "map", "index", "name", "SliderOrientationProvider", "useSliderOrientationContext", "startEdge", "endEdge", "size", "rectRef", "useDirection", "dir", "isDirectionLTR", "getValueFromPointer", "pointerPosition", "rect", "getBoundingClientRect", "input", "width", "output", "linearScale", "left", "style", "clientX", "onSlideStart", "onSlideMove", "isBackKey", "onStepKeyDown", "sliderRef", "ref", "height", "top", "clientY", "SliderImpl", "context", "composeEventHandlers", "onKeyDown", "onHomeKeyDown", "preventDefault", "onEndKeyDown", "concat", "onPointerDown", "target", "setPointerCapture", "pointerId", "has", "onPointerMove", "hasPointerCapture", "onPointerUp", "releasePointerCapture", "onSlideEnd", "TRACK_NAME", "SliderTrack", "trackProps", "RANGE_NAME", "SliderRange", "rangeProps", "valuesCount", "percentages", "convertValueToPercentage", "offsetStart", "offsetEnd", "THUMB_NAME", "SliderThumb", "getItems", "thumb", "setThumb", "findIndex", "item", "SliderThumbImpl", "thumbProps", "useSize", "percent", "label", "getLabel", "orientationSize", "thumbInBoundsOffset", "getThumbInBoundsOffset", "add", "delete", "transform", "position", "display", "onFocus", "BubbleInput", "inputProps", "prevValue", "usePrevious", "inputProto", "window", "HTMLInputElement", "prototype", "descriptor", "Object", "getOwnPropertyDescriptor", "setValue", "set", "Event", "bubbles", "call", "dispatchEvent", "sort", "a", "b", "maxSteps", "percentPerStep", "totalValues", "distances", "abs", "closestDistance", "halfWidth", "halfPercent", "offset", "getStepsBetweenValues", "slice", "minStepsBetweenValues", "stepsBetweenValues", "actualMinStepsBetweenValues", "ratio", "split", "rounder", "pow", "Root", "Track", "Range", "Thumb"]
}
